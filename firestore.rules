/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is
 * siloed under a user-specific path (`/users/{userId}`), ensuring that a user can
 * only ever access their own information, tasks, and categories. This approach,
 * often called a "data silo" pattern, provides maximum security and privacy by
 * default. (Forcing redeployment to fix permissions).
 *
 * Data Structure: The data is organized hierarchically with the `users` collection
 * at the root. Each user's profile, categories, and tasks are stored in
 * subcollections under their unique user document (`/users/{userId}`).
 *   - /users/{userId} -> UserProfile
 *   - /users/{userId}/categories/{categoryId} -> Category
 *   - /users/{userId}/tasks/{taskId} -> Task
 *
 * Key Security Decisions:
 * - Strict Ownership: All operations (read, write, delete) are restricted to the
 *   authenticated user who owns the data. There is no concept of public or shared
 *   data.
 * - No User Listing: It is impossible to query or list the top-level `/users`
 *   collection, preventing enumeration of all users in the system.
 * - Path-Based Authorization: Security is enforced by comparing the authenticated
 *   user's UID (`request.auth.uid`) with the `{userId}` parameter in the document
 *   path. This is highly performant as it avoids extra database reads (`get()`)
 *   for authorization checks.
 *
 * Denormalization for Authorization: To ensure performant and secure rules, the
 * `userId` is present in the path of every document. Additionally, documents in
 * subcollections (Category, Task) contain a `userId` field, and the UserProfile
 * contains an `id` field. The rules validate on `create` and `update` that these
 * internal fields match the path, ensuring data integrity and preventing a document
 * from being associated with the wrong user.
 *
 * Structural Segregation: The entire data model is built on structural segregation.
 * By placing all of a user's data within their own document tree, queries are
 * naturally and securely scoped. A query for tasks can only be run against
 * `/users/{userId}/tasks`, which the rules can easily secure for the owner.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of the document
     * based on the `userId` from the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the owner AND the document already exists.
     * Crucial for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates a new UserProfile on creation.
     * Ensures the creator is the owner and the internal 'id' field matches the UID.
     */
    function isCreatingValidUserProfile(userId) {
      let isCreatingOwnDoc = isOwner(userId);
      let hasValidId = request.resource.data.id == userId;
      return isCreatingOwnDoc && hasValidId;
    }

    /**
     * Enforces immutability of the 'id' field on UserProfile updates.
     */
    function hasImmutableUserProfileId() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates a new document in a user's subcollection (e.g., Category, Task).
     * Ensures the document's internal 'userId' field matches the owner's UID in the path.
     */
    function hasValidOwnerLinkOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the 'userId' field on subcollection document updates.
     */
    function hasImmutableOwnerLink() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // User Profile Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow (get, update, delete) A signed-in user with UID 'user_abc' accessing '/users/user_abc'.
     * @allow (create) A new user with UID 'user_xyz' creating their own document at '/users/user_xyz'.
     * @deny (get) User 'user_abc' trying to access '/users/user_xyz'.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree and allows self-creation of a profile.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users.
      allow create: if isCreatingValidUserProfile(userId);
      allow update: if isExistingOwner(userId) && hasImmutableUserProfileId();
      allow delete: if isExistingOwner(userId);

      // ----------------------------------------------------------------------
      // Category Subcollection Rules
      // ----------------------------------------------------------------------

      /**
       * @description Controls access to a user's private categories.
       * @path /users/{userId}/categories/{categoryId}
       * @allow (get, list, create, update, delete) User 'user_abc' operating on documents under '/users/user_abc/categories/'.
       * @deny (any) User 'user_abc' trying to access anything under '/users/user_xyz/categories/'.
       * @principle Enforces strict document ownership within a user's private subcollection.
       */
      match /categories/{categoryId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidOwnerLinkOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }

      // ----------------------------------------------------------------------
      // Task Subcollection Rules
      // ----------------------------------------------------------------------

      /**
       * @description Controls access to a user's private tasks.
       * @path /users/{userId}/tasks/{taskId}
       * @allow (get, list, create, update, delete) User 'user_abc' operating on documents under '/users/user_abc/tasks/'.
       * @deny (any) User 'user_abc' trying to access anything under '/users/user_xyz/tasks/'.
       * @principle Enforces strict document ownership within a user's private subcollection.
       */
      match /tasks/{taskId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidOwnerLinkOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
